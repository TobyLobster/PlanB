#########################################################################################
#
# Plan B disassembler
#
#########################################################################################



# Quick patch to make it work under DFS 0.9:
# Reads random numbers from OS ROM, not DFS
#
# http://bbcmicro.co.uk//jsbeeb/play.php?autoboot&disc=http://bbcmicro.co.uk//gameimg/discs/586/Disc033-PlanB.ssd&noseek&patch=@4cb3,3b83:fa;@4cb3,3b87:c0;@4cb3,4ea0:ef;@4cb3,4ea2:c0



# Alternative (lets face it, better) random number routine:
#
# rng_zp_low = $38
# rng_zp_high = $39
#
# seeding
#     lda #1 ; seed, can be anything except 0
#     sta rng_zp_low
#     lda #0
#     sta rng_zp_high
# ; ...
# random
#     lda rng_zp_high
#     lsr
#     lda rng_zp_low
#     ror
#     eor rng_zp_high
#     sta rng_zp_high ; high part of x ^= x << 7 done
#     ror ; A has now x >> 9 and high bit comes from low byte
#     eor rng_zp_low
#     sta rng_zp_low ; x ^= x >> 9 and the low part of x ^= x << 7 done
#     eor rng_zp_high
#     sta rng_zp_high ; x ^= x << 8 done
#     rts

from commands import *
import acorn
import trace6502
import config

#config.indent_loops = False
config.set_label_references(False)
#config.set_hex_dump(False)
#config.set_hex_dump_max_bytes(0)
#config.show_autogenerated_labels = False
#config.show_cpu_state = False
config.show_char_literals = False

memory_binary = config.memory_binary
return_index = 0
found_keys = {}
return_array = {}

def include_terminator_fn(by):
    return True

def hook(subroutine_addr, addr):
    return stringhi(addr + 3, include_terminator_fn)

def get_u8(addr):
    return memory_binary[addr]

def my_label_maker(addr, context, suggestion):
    global return_index

    if get_u8(addr) == 0x60:
        if not addr in return_array:
            return_index += 1
            return_array[addr] = return_index

        return "return" + str(return_array[addr])

    if (context >= 0x4192) and (context < 0x4200):
        if suggestion[0] == "room_decode_rect_width":
            return "current_room_header2"
        if suggestion[0] == "room_decode_sprite_height":
            return "current_room_door_celly"
        if suggestion[0] == "room_decode_sprite_width":
            return "current_room_door_cellx"
    return suggestion

def inkey_expr(addr):
    key = get_u8(addr)
    if key in acorn.inkey_enum:
        expr(addr, acorn.inkey_enum[key])
        found_keys[key] = True
    else:
        assert("inkey not found")

def picture_sprite(addr, lab, width, height):
    label(addr, lab)
    bytes_per_line = (width + 7) // 8
    byte(addr, height * bytes_per_line, bytes_per_line)

    picture_binary(addr, height * bytes_per_line)

set_label_maker_hook(my_label_maker)
load(0x1210, "ORIGINAL_DISK/PLANB")

acorn.mos_labels()
acorn.hardware_bbc()
constant(0x07, "osword_sound")

sprite_widths = [
    2,1,1,1,1,1,1,1,1,2,1,1,
    1,1,1,1,2,4,1,1,1,1,1,1,
    1,1,2,2,1,1,1,4,1,1,1,1,
    1,1,2,2,2,1,1,1,1,1,1,1,
    4,4,4,4,4,4,4,4,4,4,4,4,
    4,3,3,3,3,3,3,3,3,1,1,1,
    1,2,2,2,2,3,3,3,3,4,4,4,
    4 ]
sprite_heights = [
    1,1,1,1,1,1,1,2,2,1,1,1,
    1,2,1,1,2,2,1,1,1,1,1,1,
    1,1,1,1,1,1,1,2,1,1,1,1,
    2,1,3,3,3,1,1,4,4,4,4,4,
    1,1,1,1,1,4,4,4,4,4,4,4,
    4,3,3,3,3,3,3,3,3,1,1,1,
    1,2,2,2,2,3,3,3,3,4,4,4,
    4 ]

constant(55, "room_count")

# Zero page
label(0x0000, "cell_x")
label(0x0001, "cell_y")
label(0x0002, "sprite_pixel_width_minus_one")
label(0x0003, "sprite_cell_height")
label(0x0005, "delta_x")
label(0x0006, "delta_y")
label(0x0007, "room_decode_sprite")
label(0x0008, "current_room_low")
label(0x0009, "current_room_high")
label(0x000a, "plot_strip_loop_counter")
label(0x000b, "temp_byte")
label(0x000c, "collision_map_byte_to_write")
label(0x000d, "current_room_index")
label(0x000e, "offset_to_start_of_computers")
label(0x000f, "offset_to_start_of_collectibles")

label(0x0011, "current_room_header")
label(0x0013, "room_decode_sprite_height")
label(0x0014, "room_decode_sprite_width")
label(0x0015, "room_decode_rect_width")
label(0x0016, "temp_y")
label(0x001a, "player_x")
label(0x001b, "player_y")
label(0x001c, "player_sprite")
label(0x001d, "temp_addr_low")
label(0x001e, "temp_addr_high")
label(0x0022, "old_player_x")
label(0x0023, "old_player_y")
label(0x0024, "number_of_key0_held")
label(0x0025, "number_of_key1_held")
label(0x0026, "number_of_key2_held")
label(0x0027, "number_of_key3_held")
label(0x0028, "score_digits_0")
label(0x0029, "score_digits_1")
label(0x002a, "score_digits_2")
label(0x002b, "score_digits_3")
label(0x002c, "score_digits_4")
label(0x002d, "score_digits_5")
label(0x002e, "score_digits_6")
label(0x002f, "print_addr_low")
label(0x0030, "print_addr_high")
label(0x0031, "temp_slash_divisor")
label(0x0032, "energy_bar_level")
label(0x0033, "ammo_bar_level")
label(0x0035, "sound_duration")
label(0x0036, "stack_ptr")
label(0x0038, "rnd_rom_addr_low")
label(0x0039, "rnd_rom_addr_high")
label(0x003a, "temp_counter")
label(0x003b, "temp_store_y")
label(0x003c, "rnd_offset")
label(0x003d, "sprite_mask")
label(0x003e, "remember_x")
label(0x003f, "remember_y")
label(0x0040, "computer_bar_level")
label(0x0041, "suppress_sound_flag")
label(0x0042, "music_index")
label(0x0044, "title_offset")
label(0x0045, "half_length_of_room_title")

label(0x0400, "current_room_cache")
label(0x0500, "dying_items")
label(0x0501, "dying_items + 1")
label(0x0502, "dying_items + 2")
label(0x0503, "dying_items + 3")
label(0x0580, "ammo_slots")
label(0x0581, "ammo_slots + 1")
label(0x0582, "ammo_slots + 2")


label(0x0e00, "clock")

# Memory locations
comment(0x1210, "There are 85 sprites. Sprites are stored 8x8 character cells which are ordered upside down and from right to left.")

def get_addr(addr, x, y, w, h):
    y = y ^ 7
    #y = h - 1 - y
    x = (w - 1) - x
    return addr + int(y/8)*w + int(x/8)*8 + (y & 7)

def centre_row(row):
    split_row = row.splitlines()
    max_width = 0
    for entry in split_row:
        max_width = max(len(entry), max_width)

    for i in range(0, len(split_row)):
        extra_spaces_to_left = int((80 - len(split_row[i])) / 2)
        if extra_spaces_to_left > 0:
            split_row[i] = " "*extra_spaces_to_left + split_row[i]
        split_row[i] = split_row[i].rstrip()

    return "\n".join(split_row)


# Append a multiline ASCII sprite to the right of an existing sequence of ASCII sprites in a row
def append_string(row, row_width, string):
    split_row = row.splitlines()
    max_width = 0
    for entry in split_row:
        max_width = max(len(entry), max_width)

    # make sure there are enough rows
    split_string = string.splitlines()
    extra_rows = len(split_string) - len(split_row)
    while (extra_rows > 0):
        split_row.append("")
        extra_rows -= 1

    # make sure they are all the same width
    for i in range(0, len(split_row)):
        extra_spaces_to_add = max_width - len(split_row[i])
        split_row[i] += " "*extra_spaces_to_add

    # append to each row
    for i in range(0, len(split_string)):
        split_row[i] += split_string[i]
    return "\n".join(split_row)

def setc(string, i, val):
    return string[:i] + val + string[i+1:]

gallery_gap = 6

i = 0
addr = 0x1210
row = ""
row_width = 0
row_height = 0
for i in range(0, 85):
    stri = str(i)
    picture_sprite(addr, "sprite" + stri, 8, sprite_widths[i] * sprite_heights[i] * 8)

    # ASCII art
    span = 1 + (8 * sprite_widths[i])
    byte_string = '?' * (span * 8 * sprite_heights[i])
    for y in range(0, 8 * sprite_heights[i]):
        for x in range(0, 8 * sprite_widths[i]):
            test_addr = get_addr(addr, x, y, 8 *sprite_widths[i], 8 * sprite_heights[i])
            by = get_u8(test_addr)
            bit = (128 >> (x & 7))
            if by & bit:
                c = '#'
            else:
                c = ' '
            byte_string = setc(byte_string, x + y*span, c)
        byte_string = setc(byte_string, (y + 1)*span - 1, '\n')

    framed_string = "/" + "-"*8 * sprite_widths[i] + "\\"  + " "*gallery_gap + "\n"
    for line in byte_string.splitlines():
        line = "|" + line + "|" + " "*gallery_gap
        framed_string += line + "\n"
    framed_string += "\\" + "-"*8 * sprite_widths[i] + "/" + " "*gallery_gap
    frame_width = 1 + 8 * sprite_widths[i] + 1
    title_width = len("sprite" + str(i))
    left_space = int((frame_width - title_width) / 2)
    right_space = frame_width - left_space - title_width
    framed_string += "\n" + " " * left_space + "sprite" + str(i) + " "*right_space + " "*gallery_gap + "\n\n"

    # Start a new row?
    if ((row_width + frame_width) >= 80) or ((row_height != 0) and (row_height != sprite_heights[i])):
        row = centre_row(row)
        formatted_comment(0x1210, "\n" + row)
        row = ""
        row_width = 0
        row_height = 0

    row = append_string(row, row_width, framed_string)
    row_width += frame_width + gallery_gap
    row_height = sprite_heights[i]

    # Move on to next sprite
    addr += sprite_heights[i] * 8 * sprite_widths[i]
    i = i + 1

if (row != ""):
    row = centre_row(row)
    formatted_comment(0x1210, "\n" + row)

comment(0x1fe8, "Width (in pixels) of each sprite")
comment(0x203d, "Height (in character cells) of each sprite")
label(0x1fe8, "sprite_width_table")
byte(0x1fe8, 85)
label(0x203d, "sprite_height_table")
byte(0x203d, 85)

comment(0x2092, "The address of each sprite, stored as offsets from sprite_0")
label(0x2092, "sprite_offset_table_low")
byte(0x2092, 85)
label(0x20e7, "sprite_offset_table_high")
byte(0x20e7, 85)
label(0x0600, "highscore_table_names")
label(0x6fa, "highscore_table_scores")

label(0x394b, "room_definition_low")
label(0x3982, "room_definition_high")

addr_low = 0x394b
addr_high = 0x3982
for i in range(0,55):
    lab = get_u8(addr_low) + 256 * get_u8(addr_high)
    name = "room_" + str(i) + "_definition"
    label(lab, name)
    byte(lab, 6)
    comment(lab, "room header", True)
    comment(lab+6, "room commands", True)
    expr(addr_low, "<" + name)
    expr(addr_high, ">" + name)
    byte(addr_low, 1)
    byte(addr_high, 1)
    addr_low += 1
    addr_high += 1

label(0x3b76, "get_random_byte")
label(0x3b8a, "skip_reset_rnd_addr")
label(0x3b97, "update_something_loop")
expr(0x3cfa, "collision_map_addr_low - 5")
expr(0x3d01, "collision_map_addr_high - 5")
expr(0x3d3d, "collision_map_addr_low - 5")
expr(0x3d44, "collision_map_addr_high - 5")

expr(0x3dea, "collision_map_addr_low - 5")
label(0x3e3e, "delta_x_table")
label(0x3e46, "delta_y_table")

label(0x3e4e, "print_following_string")
hook_subroutine(0x3e4e, "print_following_string", hook)
label(0x3e56, "print_loop")
label(0x3e6a, "increment_print_address")
label(0x3e71, "print_decimal_number")
label(0x3e8d, "divide")

expr(0x3df1, "collision_map_addr_high - 5")
label(0x3e78, "divide_by_ten_loop")
label(0x3e83, "print_digit_loop")
label(0x3e91, "divide_loop")
label(0x3ea0, "show_keys_and_zero_score")

entry(0x3eeb, "print_keys")
label(0x3eef, "print_keys_loop")
expr(0x3f0b, "'0'")
label(0x3f1d, "increment_computer_bar")
expr(0x3f1e, "<computer_bar_screen_address")
expr(0x3f20, ">computer_bar_screen_address")
label(0x3f27, "increment_energy_bar")
expr(0x3f28, "<energy_bar_screen_address")
expr(0x3f2a, ">energy_bar_screen_address")
expr(0x3f2e, "100")
label(0x3f35, "increment_ammo_bar")
expr(0x3f36, "<ammo_bar_screen_address")
expr(0x3f38, ">ammo_bar_screen_address")
label(0x3f42, "draw_bar")
label(0x3f5b, "bar_pixels_set_table")
expr(0x3f4f, "bar_pixels_set_table + 1")
label(0x3fa3, "check_energy")
label(0x3fad, "refill_bars")
label(0x3fb7, "refill_bars_loop")

label(0x3f64, "decrement_computer_bar")
expr(0x3f65, "<computer_bar_screen_address")
expr(0x3f67, ">computer_bar_screen_address")
label(0x3f6f, "decrement_energy_bar")
expr(0x3f79, "<energy_bar_screen_address")
expr(0x3f7b, ">energy_bar_screen_address")
label(0x3f7e, "decrement_ammo_bar")
expr(0x3f87, "<ammo_bar_screen_address")
expr(0x3f89, ">ammo_bar_screen_address")
label(0x3f8b, "print_decremented_bar")
comment(0x3fa7, "out_of_energy")
expr(0x3fb4, "100")
label(0x3fe3, "print_score")
label(0x3fcc, "add_to_score_loop")
label(0x3fca, "add_a_to_score")
label(0x3fc8, "increment_score")
label(0x3ff4, "print_score_loop")
label(0x3ffe, "wait")
label(0x4017, "wait_clock_read_value")
label(0x401c, "wait_clock_write_value")
label(0x401d, "check_sound_on_off")
label(0x4028, "skip")
label(0x4034, "check_paws")
label(0x404c, "paws_loop")


label(0x4065, "check_play_sound_a")
label(0x406c, "pull_and_play_sound_a")
label(0x406d, "play_sound_a")
expr(0x407b, "osword_sound")

label(0x4083, "skip_sound")
label(0x4088, "sound_addr_table_low")
expr(0x4088, "<sound0")
expr(0x4089, "<sound1")
expr(0x408a, "<sound2")
expr(0x408b, "<sound3")
expr(0x408c, "<sound4")
expr(0x408d, "<sound5")
expr(0x408e, "<sound6")
expr(0x408f, "<sound7")
expr(0x4090, "<sound8")
label(0x4091, "sound_addr_table_high")
byte(0x4091, 0x4091-0x4088)
expr(0x4091, ">sound0")
expr(0x4092, ">sound1")
expr(0x4093, ">sound2")
expr(0x4094, ">sound3")
expr(0x4095, ">sound4")
expr(0x4096, ">sound5")
expr(0x4097, ">sound6")
expr(0x4098, ">sound7")
expr(0x4099, ">sound8")
label(0x409a, "sound0")
byte(0x409a, 8)
label(0x409a + 1*8, "sound1")
byte(0x409a + 1*8, 8)
label(0x409a + 2*8, "sound2")
byte(0x409a + 2*8, 8)
label(0x409a + 3*8, "sound3")
byte(0x409a + 3*8, 8)
label(0x409a + 4*8, "sound4")
byte(0x409a + 4*8, 8)
label(0x409a + 5*8, "sound5")
byte(0x409a + 5*8, 8)
label(0x409a + 6*8, "sound6")
byte(0x409a + 6*8, 8)
label(0x409a + 7*8, "sound7")
byte(0x409a + 7*8, 8)
label(0x409a + 8*8, "sound8")
byte(0x409a + 8*8, 8)
label(0x40c8, "sound5_duration")
label(0x40d0, "sound6_duration")
label(0x40d6, "sound7_pitch")
blank(0x40e2)
label(0x40e2, "collision_map_addr_low")
byte(0x40e2, 27)
label(0x40fd, "collision_map_addr_high")
byte(0x40fd, 27)
blank(0x4118)
label(0x4118, "room_decoder_routine_table_low")
expr(0x4118, "<room_decode_plot_strip")
expr(0x4119, "<room_decode_plot_strip")
expr(0x411a, "<room_decode_set_sprite")
expr(0x411b, "<room_decode_set_deltax_or_y")
expr(0x411c, "<room_decode_set_cellxy")
expr(0x411d, "<room_decode_move_in_delta_direction")
expr(0x411e, "<room_decode_set_sprite")
expr(0x411f, "<room_decode_draw_rect")

label(0x4120, "room_decoder_routine_table_high")
byte(0x4120, 8)
expr(0x4120, ">room_decode_plot_strip")
expr(0x4121, ">room_decode_plot_strip")
expr(0x4122, ">room_decode_set_sprite")
expr(0x4123, ">room_decode_set_deltax_or_y")
expr(0x4124, ">room_decode_set_cellxy")
expr(0x4125, ">room_decode_move_in_delta_direction")
expr(0x4126, ">room_decode_set_sprite")
expr(0x4127, ">room_decode_draw_rect")

blank(0x4128)
label(0x4128, "clear_memory")
label(0x4130, "clear_memory_loop")
label(0x414b, "decode_room_definition")
label(0x4166, "copy_current_room_data_to_cache_loop")
comment(0x416e, "handle all room commands")
label(0x4170, "decode_room_commands_loop")
label(0x418b, "routine_opcode")
label(0x418c, "routine_low")
label(0x418d, "routine_high")
label(0x4192, "prepare_room")
label(0x419a, "prepare_room_loop")
blank(0x419f)
comment(0x419f, "copy room header to zero page")
label(0x41a1, "copy_room_header_loop")
blank(0x41aa)
formatted_comment(0x41aa, """current_room_header2:
    bit 7    = door is open flag
    bit 6    = door is vertical flag
    bit 5    = door is present flag
    bits 3-4 = door type (0-3)
    bits 0-2 = door animation stage 0-4, 0=closed, 4=open""")
comment(0x41ac, "if top bit clear then branch (animation doesn't need resetting)", True)
expr(0x41b3, "current_room_cache - 5")
comment(0x41ae, "remove top bit and bottom three bits", True)
comment(0x41b0, "set bit 2, i.e. door is in open animation state", True)

label(0x41b7, "skip_reset_bits")
comment(0x41b7, "temp storage for Y", True)
comment(0x41b9, "check bit 5", True)
comment(0x41bb, "if bit 5 clear then branch", True)
label(0x41e6, "draw_door_itself")
comment(0x41d8, "if door is horizontal then branch", True)
blank(0x41bd)
comment(0x41bd, "render the door type squares above and below the door")
comment(0x41c2, "A = door type", True)
comment(0x41c5, "add 32 to get sprite number of door type", True)
label(0x41e1, "got_door_coordinates")
label(0x41f2, "skip_door_fully_open")
comment(0x41fb, "add 48 to get sprite for horizontal door", True)
comment(0x41fe, "ALWAYS branch", True)
comment(0x4200, "add 43 to get sprite for vertical door", True)
label(0x4200, "vertical_door")
label(0x4203, "plot_door_sprite")
blank(0x420e)
label(0x420e, "plot_keys")
label(0x4215, "plot_keys_loop")
comment(0x4225, "plot down arrow", True)
label(0x4230, "next_key")
label(0x4236, "plot_computers")
label(0x423d, "plot_computers_loop")
comment(0x4247, "plot computer", True)
label(0x4251, "next_computer")
comment(0x4254, "ALWAYS branch", True)
blank(0x4256)
label(0x4256, "plot_collectibles")
label(0x425d, "plot_collectibles_loop")
comment(0x4267, "plot collectible", True)
label(0x4271, "next_collectible")
comment(0x4274, "ALWAYS branch", True)
blank(0x4276)
label(0x4276, "show_room_title")
label(0x4288, "count_room_title_length")
label(0x429c, "print_x_spaces_loop")
label(0x42a6, "print_room_name_loop")
label(0x42b1, "print_room_name_final_character")
label(0x42b6, "print_spaces_to_end_of_line")
expr(0x42d7, "current_room_cache - 1")
label(0x42e0, "set_deltax")
label(0x42e3, "negative_delta")
label(0x42d5, "set_delta")

entry(0x42ff, "room_decode_set_sprite")
comment(0x42ff, "redundant", True)
entry(0x42c5, "room_decode_set_deltax_or_y")
entry(0x42ef, "room_decode_set_cellxy")
comment(0x4301, "collision map value", True)
comment(0x4307, "collision map value", True)
comment(0x430f, "collision map value", True)
entry(0x4319, "room_decode_draw_rect")
comment(0x431b, "rectangle height", True)
comment(0x4321, "rectangle width", True)
label(0x4335, "loop_plot_rect_outer")
label(0x433c, "loop_plot_rect_inner")
comment(0x433c, "cell offset for deleting behind the sprite", True)
entry(0x4361, "room_decode_plot_strip")
entry(0x437b, "room_plot_at_first_position")
entry(0x4388, "room_decode_move_in_delta_direction")
label(0x438b, "move_in_delta_loop")

label(0x439e, "plot_room_sprite_xy")
label(0x43a2, "plot_room_sprite")
label(0x43a7, "plot_room_sprite_a")
label(0x436d, "plot_strip_loop")

label(0x43c9, "erase_loop")
label(0x43cf, "dest_low")
label(0x43d0, "dest_high")
label(0x43ce, "copy_loop")
expr(0x43ae, "collision_map_addr_low - 5")
expr(0x43b4, "collision_map_addr_high - 5")
label(0x43e8, "clear_play_area")
label(0x43f3, "play_area_screen_addr_high")
label(0x43f1, "clear_play_area_loop")
label(0x4402, "update_collision_map")
expr(0x4408, "collision_map_addr_low - 5")
expr(0x440d, "collision_map_addr_high - 5")

label(0x4431, "screen_address_table_low")
label(0x4451, "screen_address_table_high")

addr_low = 0x4431
addr_high = 0x4451
for i in range(0,32):
    expr(addr_low, "<($5800 + " + str(i) + " * $0140)")
    expr(addr_high, ">($5800 + " + str(i) + " * $0140)")
    byte(addr_low, 1)
    byte(addr_high, 1)
    addr_low += 1
    addr_high += 1

label(0x4415, "eor_top_two_bits_loop")
label(0x4417, "eor_top_two_bits_internal_loop")
blank(0x4471)
label(0x4471, "get_sprite_a_address")
expr(0x4482, "<sprite0")
expr(0x4488, ">sprite0")
label(0x448b, "get_xy_screen_address")
label(0x44a9, "plot_sprite_xy_set")
label(0x44ad, "plot_sprite_set")
label(0x44c1, "plot_loop_set")
label(0x44c3, "plot_internal_loop_set")
label(0x44c4, "source1_sprite_addr_low")
label(0x44c5, "source1_sprite_addr_high")
label(0x44c7, "dest1_screen_addr_low")
label(0x44c8, "dest1_screen_addr_high")

label(0x44e4, "plot_sprite_xy_and")
label(0x4502, "plot_loop_and")
label(0x4504, "plot_internal_loop_and")
label(0x4505, "source2_sprite_addr_low")
label(0x4506, "source2_sprite_addr_high")
label(0x4508, "mask2_sprite_addr_low")
label(0x4509, "mask2_sprite_addr_high")
label(0x450b, "dest2_screen_addr_low")
label(0x450c, "dest2_screen_addr_high")

label(0x452e, "plot_sprite_xy_clear")
label(0x4544, "plot_loop_clear")
label(0x4548, "plot_internal_loop_clear")
label(0x4549, "dest3_screen_addr_opcode")
label(0x454a, "dest3_screen_addr_low")
label(0x454b, "dest3_screen_addr_high")

label(0x4565, "plot_sprite_xy_eor")
label(0x4569, "plot_sprite_eor")
label(0x4583, "plot_loop_eor")
label(0x4585, "plot_internal_loop_eor")
label(0x4586, "source4_sprite_addr_low")
label(0x4587, "source4_sprite_addr_high")
label(0x4588, "mask4_screen_addr_opcode")
label(0x4589, "mask4_sprite_addr_low")
label(0x458a, "mask4_sprite_addr_high")
label(0x458b, "dest4_screen_addr_opcode")
label(0x458c, "dest4_screen_addr_low")
label(0x458d, "dest4_screen_addr_high")

label(0x45af, "plot_sprite_xy_mask")
expr(0x45cc, "<sprite0")
expr(0x45d4, ">sprite0")
label(0x45da, "plot_loop_mask")
label(0x45dc, "plot_internal_loop_mask")

label(0x45e3, "screen_addr_low")
label(0x45e4, "screen_addr_high")
label(0x45dd, "sprite_addr_low")
label(0x45de, "sprite_addr_high")
label(0x45df, "sprite_mask_addr_opcode")
label(0x45e0, "sprite_mask_addr_low")
label(0x45e1, "sprite_mask_addr_high")
label(0x45e2, "screen_addr_opcode")
label(0x4600, "decode_room")
label(0x4603, "decode_room_loop")
label(0x4650, "get_next_two_room_bytes_into_xy")
label(0x465c, "add_dying_item")
label(0x4663, "add_dying_item_loop")
label(0x466e, "found_dying_item_free_slot")
comment(0x46b9, "dissolve away", True)
label(0x468a, "update_dying_items")
label(0x4692, "update_dying_items_loop")
label(0x46c2, "check_if_done")
label(0x46c6, "next_dying_item")
label(0x46cd, "remove_fully_dissolved_object")
label(0x46e7, "update_player")
label(0x46fe, "skip_animation_reset")
label(0x4704, "store_player_sprite")
label(0x4706, "skip_store_player_sprite")
label(0x4736, "check_for_collision_vertical_loop")
label(0x4738, "check_for_collision_horizontal_loop")
label(0x4750, "check_for_collisions")
label(0x4759, "check_collectibles_collision_loop")
comment(0x4759, "ALWAYS branch", True)
label(0x477c, "collect")
label(0x47ab, "increment_energy_loop")
comment(0x47b2, "ALWAYS branch", True)
blank(0x47b4)
label(0x47b4, "increment_ammo_loop")
comment(0x47bb, "ALWAYS branch", True)
label(0x47bd, "check_next_collectible")
comment(0x47c0, "ALWAYS branch", True)
blank(0x47c2)
label(0x47c2, "check_keys_collision")
label(0x47c4, "check_keys_collision_loop")
label(0x4826, "check_next_key")
comment(0x4829, "ALWAYS branch", True)
label(0x482b, "write_to_collision_map")
label(0x4839, "check_ZXShift_keys")
label(0x4843, "skip3")
label(0x484d, "skip4")
label(0x4857, "skip5")

label(0x485a, "check_fire_key")
label(0x4868, "check_fire_key_done")
label(0x486b, "handle_fire_key_pressed")
comment(0x486b, "each ammo is stored in three bytes, the first byte has bottom bit for active/dead, and top bit for left/right direction, bytes two and three are the X,Y position")
label(0x486d, "find_free_ammo_slot_loop")
label(0x4877, "got_free_ammo_slot")
comment(0x4890, "if player is facing left then branch", True)
comment(0x4892, "make ammo right facing")

label(0x48a0, "skip_make_ammo_right_facing")
label(0x48b4, "handle_z_pressed")
label(0x48c0, "skip_turn_left")
label(0x48dc, "change_room_local")
label(0x48df, "handle_x_pressed")
label(0x48eb, "skip_turn_right")
expr(0x4948, "collision_map_addr_low - 5")
expr(0x494f, "collision_map_addr_high - 5")
label(0x4909, "handle_shift_pressed")
label(0x4925, "update_falling")
label(0x4954, "read_key")
expr(0x4e9d, "clock + 1")
label(0x49b9, "update_ammo")
expr(0x49cb, "collision_map_addr_low - 5")
expr(0x49d2, "collision_map_addr_high - 5")

expr(0x4a72, "current_room_cache + 1")
comment(0x4a7d, "add 50 to score")
label(0x4aff, "check_return_key")
label(0x4b09, "check_for_doors_loop")
label(0x4b3e, "next_door")
comment(0x4b43, "ALWAYS branch", True)
label(0x4b45, "update_key_count")
label(0x4b65, "copy_cache_back_to_room_definition")
label(0x4b83, "copy_room_definition_to_cache_loop")
label(0x4b8b, "plot_updated_number")
label(0x4bee, "change_room")
label(0x4bf3, "copy_current_room_cache_back_to_definition_loop")
label(0x4bfe, "find_new_room_loop")
label(0x4c11, "found_new_room")
label(0x4c36, "skip1")
label(0x4c40, "skip2")
label(0x4c5c, "is_exit_found")
comment(0x4c5f, "check type of exit", True)
comment(0x4c7b, "ALWAYS branch", True)
blank(0x4c7d)

comment(0x4c95, "found exit")
label(0x4c96, "no_exit")
comment(0x5004, "add 5000 to score")

expr(0x4c67, "current_room_cache + 1")
entry(0x4cb3, "entry_point")
expr(0x4cbd, "<event_routine")
expr(0x4cbf, ">event_routine")
label(0x4cda, "title_and_game_loop")
label(0x4d01, "reset_rooms_and_goto_title")
label(0x4d07, "reset_music_rooms_and_goto_title")
label(0x4d0d, "attract_loop")
label(0x4e17, "press_space")
label(0x4e35, "wait_for_space_loop")
label(0x4e4e, "space_pressed")
label(0x4e55, "wait_for_key")
label(0x4e70, "wait_for_key_loop")
label(0x4e78, "check_for_key")
label(0x4e81, "pull_and_reset")
label(0x4e86, "show_title_and_play_game")
label(0x4ee9, "end_of_game")
label(0x4f4a, "game_completed")
label(0x4f51, "play_completion_sounds_loop")
label(0x4f63, "wait_for_sounds_to_finish_loop")
entry(0x4fd2, "destroyed_computer")
label(0x5032, "get_channel_1_bytes_free")
label(0x503b, "reset_rooms")
label(0x503f, "reset_rooms_loop")
label(0x504e, "reset_room_loop")
label(0x505c, "skip_reset_item")
label(0x5063, "goto_next_room")
expr(0x5071, "room_count")
label(0x5084, "set_colour_one_white")
label(0x508e, "set_colour_one_black")
label(0x5098, "reset_current_text_colours")
label(0x50a3, "set_inverse_colours")
label(0x50ae, "one_time_init")
label(0x50b2, "copy_highscores_loop")
label(0x50b4, "copy_highscores_source_addr_high")
label(0x50b5, "store_highscore_opcode")
label(0x50b7, "copy_highscores_dest_addr_high")
expr(0x50b3, "initial_highscore_table - $70")
expr(0x50b6, "highscore_table_names - $70")
label(0x50e8, "envelope1")
label(0x50f6, "envelope2")
label(0x5104, "envelope3")
label(0x5112, "envelope4")
byte(0x5120, 0x519d-0x5120)
label(0x5120, "music_pitch_table")
entry(0x519d, "event_routine")
label(0x51c0, "play_silence")
label(0x51c2, "play_note")
label(0x51c8, "reset_music")
label(0x522a, "no_highscore")
label(0x5277, "update_highscores")
label(0x5283, "make_room_for_new_highscore")
expr(0x5294, "highscore_table_names + 25")
label(0x5290, "copy_highscore_name_loop")
label(0x52a3, "copy_score_loop")
expr(0x52a7, "highscore_table_scores - 7")
expr(0x52aa, "score_digits_0 - 1")
label(0x53a0, "compare_scores")
label(0x53a4, "compare_scores_loop")
label(0x53b2, "show_highscore_table")
label(0x53c4, "show_highscores_loop")
label(0x53cd, "skip_invert_colours")
label(0x53dc, "skip_leading_space")
label(0x53e7, "write_highscore_name_loop")
label(0x53fc, "write_highscore_loop")

string(0x5417, 25)
string(0x5417 + 1*25, 25)
string(0x5417 + 2*25, 25)
string(0x5417 + 3*25, 25)
string(0x5417 + 4*25, 25)
string(0x5417 + 5*25, 25)
string(0x5417 + 6*25, 25)
string(0x5417 + 7*25, 25)
string(0x5417 + 8*25, 25)
string(0x5417 + 9*25, 25)
string(0x5417 + 10*25, 7)
string(0x5417 + 10*25 + 1*7, 7)
string(0x5417 + 10*25 + 2*7, 7)
string(0x5417 + 10*25 + 3*7, 7)
string(0x5417 + 10*25 + 4*7, 7)
string(0x5417 + 10*25 + 5*7, 7)
string(0x5417 + 10*25 + 6*7, 7)
string(0x5417 + 10*25 + 7*7, 7)
string(0x5417 + 10*25 + 8*7, 7)
string(0x5417 + 10*25 + 9*7, 7)
comment(0x5417, "High score table")
label(0x5417, "initial_highscore_table")
label(0x5800, "address_to_overwrite")
label(0x58d0, "energy_bar_screen_address")
label(0x5a10, "ammo_bar_screen_address")
label(0x5b50, "computer_bar_screen_address")

expr(0x3db7, "current_room_cache + 1")
expr(0x4654, "current_room_cache + 1")
expr(0x4761, "current_room_cache + 1")
expr(0x47cc, "current_room_cache + 1")
expr(0x4a20, "current_room_cache + 1")
expr(0x4a39, "current_room_cache + 1")
expr(0x4a59, "current_room_cache + 1")
expr(0x4a67, "current_room_cache + 1")
expr(0x4c8f, "current_room_cache + 1")
expr(0x4657, "current_room_cache + 2")
expr(0x476f, "current_room_cache + 2")
expr(0x47d6, "current_room_cache + 2")
expr(0x4a2a, "current_room_cache + 2")
expr(0x4a3c, "current_room_cache + 2")
expr(0x4a63, "current_room_cache + 2")
expr(0x4a75, "current_room_cache + 2")
expr(0x4c75, "current_room_cache + 2")
expr(0x4c81, "current_room_cache + 2")
expr(0x4b60, "current_room_cache + 3")
expr(0x4c12, "current_room_cache + 3")
expr(0x4b59, "current_room_cache + 4")
expr(0x4c15, "current_room_cache + 4")

# **************************************************************************************
stringhi(0x2193, include_terminator_fn)
stringhi(0x21d6, include_terminator_fn)
stringhi(0x2253, include_terminator_fn)
stringhi(0x22c5, include_terminator_fn)
stringhi(0x230f, include_terminator_fn)
stringhi(0x2335, include_terminator_fn)
stringhi(0x23d1, include_terminator_fn)
stringhi(0x2478, include_terminator_fn)
stringhi(0x2505, include_terminator_fn)
stringhi(0x258a, include_terminator_fn)
stringhi(0x260e, include_terminator_fn)
stringhi(0x271b, include_terminator_fn)
stringhi(0x2784, include_terminator_fn)
stringhi(0x27f6, include_terminator_fn)
stringhi(0x285c, include_terminator_fn)
stringhi(0x28e2, include_terminator_fn)
stringhi(0x2974, include_terminator_fn)
stringhi(0x29e3, include_terminator_fn)
stringhi(0x2ab9, include_terminator_fn)
stringhi(0x2c82, include_terminator_fn)
stringhi(0x2d7c, include_terminator_fn)
stringhi(0x2e0e, include_terminator_fn)
stringhi(0x314d, include_terminator_fn)
stringhi(0x31f1, include_terminator_fn)
stringhi(0x3276, include_terminator_fn)
stringhi(0x32f9, include_terminator_fn)
stringhi(0x367d, include_terminator_fn)
stringhi(0x377d, include_terminator_fn)
stringhi(0x38db, include_terminator_fn)
stringhi(0x393f, include_terminator_fn)
stringhi(0x3a1c, include_terminator_fn)
stringhi(0x3ab6, include_terminator_fn)
stringhi(0x3b0f, include_terminator_fn)
stringhi(0x3b65, include_terminator_fn)
string(0x3eb5)
string(0x3ea5)
string(0x3eab)
string(0x3eb8)

inkey_expr(0x401e)
inkey_expr(0x4029)
inkey_expr(0x4035)
inkey_expr(0x404d)
inkey_expr(0x483a)
inkey_expr(0x4844)
inkey_expr(0x484e)
inkey_expr(0x485f)
inkey_expr(0x4b00)
inkey_expr(0x4e3c)
inkey_expr(0x4e43)

# Define key constants
for key in found_keys:
    constant(key, acorn.inkey_enum[key])

go()

print("free_total = $5800 - *")
